<html>

<head>
<title>Example: If-Then-Else Statement</title>
<link REL="STYLESHEET" HREF="../gold-parser-doc-style.css">
<base target="_self">
<style type="text/css">

.ssCodeText    {font-family: "Courier New", Courier, monospace; font-weight: bold;}

.ssListHeaderText
{
  font-family: Arial;
  font-size: 10pt;
  font-weight: bold;
  color: #000000;
}

.ssListDescCell 
{
  font-family: Arial;
  vertical-align: top;
  font-size: 9pt;
  color: #000000;
  padding-top: 8px;
  padding-bottom: 24px;
  border-top: 2px solid #C0C0C0;
}

</style>
</head>

<body class="ssMainPage">

<h1>Glossary</h1>

<table border="0" width="100%" class="ssListTable" cellspacing="0" cellpadding="0">
      <tr>
        <td class="ssListItemCell" nowrap><a name="BackusNaur"></a><span class="ssListHeaderText">Backus-Naur
        Form</span></td>
        <td class="ssListItemCell">Backus-Naur Form is a notation used to describe the syntax of
        programming languages. In particular is it used to define
		<a href="define-rules.htm">productions</a>.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Configuration"></a><span class="ssListHeaderText">Configuration</span></td>
        <td class="ssListItemCell">In parsing terms, a configuration is a production in the
        process of being completed. Configurations play a major role in the construction of 
		<a href="../../articles/glossary.htm#LRParsing">LR parse</a> tables.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="CFG"></a><span class="ssListHeaderText">Deterministic
        Finite <br>
        Automata</span></td>
        <td class="ssListItemCell">A Deterministic Finite Automaton is often used to analyze a
        series of characters.&nbsp; Often it is implemented using state driven transition graph.
        Please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="../../articles/dfa.htm">Deterministic Finite Automata</a> page for more information.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Grammar"></a><span class="ssListHeaderText">Grammar</span></td>
        <td class="ssListItemCell">Please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="../../articles/bnf.htm">Grammar and Backus-Naur
        Form</a> page</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="LALRParsing"></a><span class="ssListHeaderText">LALR
        Parsing</span></td>
        <td class="ssListItemCell">LALR Parsing, or &quot;<u>L</u>ook<u>a</u>head LR
        parsing&quot;, is a variant of <a href="#LR Parsing">LR Parsing</a> that
        combines different &quot;configurations&quot; to limit the size of the parse tables. As a
        result, the algorithm is slightly less powerful than the LR Parsing. Grammars that can be
        parsed by a LR parser, might be found to be &quot;ambiguous&quot; by LALR. However, this
        is very rarely the case and real-world examples are few. <p>The number of states
        eliminated by LALR are sometimes huge. The C programming language, for instance, has over
        10,000 LR states. LALR drops this number to slightly more than 200. </p>
		  </td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="LRParsing"></a><span class="ssListHeaderText">LR
        Parsing</span></td>
        <td class="ssListItemCell"><p>LR Parsing, or <strong><u>L</u></strong>eft-to-right <u><strong>
		R</strong></u>ight-derivative parsing, uses tables to determine when a 
		rule is complete and when additional tokens are needed to be read from 
		the source.The LR Parser does very little &quot;thinking&quot; at runtime. All 
		decisions are based on the content of the parse tables. The 
		construction of these tables where all the &quot;thinking&quot; takes place. LR 
		parser generators, such as YACC and GOLD, construct these tables by 
		analyzing the grammar and determining all the possible &quot;states&quot; the 
		system can be in when parsing. </p>
		<p>Each state represents a point in the parse process where a number of tokens have been
        read from the source and rules are in different states of completion. Each production in a
        state of completion is called a &quot;configuration&quot; and each state is really a
        configuration set.</p>
        <p>LR parse tables can be huge, and, as a result, often a variant of LR Parsing is used.
        For more information, please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="../../articles/lalr.htm">LALR Algorithm</a> page.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Nonterminal"></a><span class="ssListHeaderText">Nonterminal</span></td>
        <td class="ssListItemCell">A nonterminal is a symbol used in Backus-Naur 
		form represent a syntactic structures defined in the grammar.<br><br>Please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="define-rules.htm">Define 
		Rules</a> page</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="NullableRule"></a><span class="ssListHeaderText">Nullable Rule</span></td>
        <td class="ssListItemCell"><p>A nullable rule is a type of<a href="../../articles/glossary.htm#Rule"> rule</a>
        which is optional, or in other words, can contain no symbols. In the GOLD Meta-Language, a
        nullable rule can be specified by adding a blank entry:</p> 
          <table border="0" class="ssCodeTable" cellspacing="0" cellpadding="0">
            <tr>
              <td width="100%" class="ssCodeTableBody" nowrap><span class="ssCodeText"><code>&lt;Optional
              ID&gt; ::= Identifier<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</code></span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Parser"></a><span class="ssListHeaderText">Parser</span></td>
        <td class="ssListItemCell">A parser is software, such as a procedure or 
		library, that organizes text into a set of logical units used by a 
		programming language. </td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="ParserGenerator"></a><span class="ssListHeaderText">Parser Generator</span></td>
        <td class="ssListItemCell">A parser generator is a generic term that refers to any
        software program that helps develop a working parser. Examples include the GOLD, YACC and
        ANTLR.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Production"></a><span class="ssListHeaderText">Production</span></td>
        <td class="ssListItemCell">Please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="define-rules.htm">Define 
		Rules</a> page.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="ReduceReduceConflict"></a><span class="ssListHeaderText">Reduce-Reduce<br>
        Conflict</span></td>
        <td class="ssListItemCell">A Reduce-Reduce Conflict is a caused when a grammar allows two
        or more different<a href="../../articles/glossary.htm#Rule"> rules</a> to be reduced at the same time,
        for the same token. When this happens, the grammar becomes ambiguous since a program can
        be interpreted more than one way.<p>For instance, assume you have the following grammar:</p>
       
          <table border="0" class="ssCodeTable" cellspacing="0" cellpadding="0">
            <tr>
              <td width="100%" class="ssCodeTableBody" nowrap>&lt;S&gt;
              ::= &lt;A&gt; | &lt;B&gt;<br>
              <br>
              &lt;A&gt; ::= Identifier<br>
              &lt;B&gt; ::= Identifier</td>
            </tr>
          </table>
        
        <p>When the system reads an identifier, it cannot determine if it has completed
		<span class="CodeInline">&lt;A&gt;</span> or<span class="CodeInline">&lt;B&gt;</span>.
        </p>
        <p>When a <a href="../../articles/glossary.htm#LALRParsing">LALR</a> parser generator is analyzing a
        grammar and constructing the parse tables, these conflicts are located immediately.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="RegularExpression"></a><span class="ssListHeaderText">Regular Expression</span></td>
        <td class="ssListItemCell">A Regular Expression is a notation used describe patterns of
        characters. In programming language theory, they are often used to describe a languages'
        terminals. For more information, please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="define-terminals.htm">Define 
		Terminals</a> page</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Rule"></a><span class="ssListHeaderText">Rule</span></td>
        <td class="ssListItemCell">Please see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="define-rules.htm">Define 
		Rules</a> page.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Semantics"></a><span class="ssListHeaderText">Semantics</span></td>
        <td class="ssListItemCell">The semantics of a programming language refers to how the
        actual statements, constructs, etc... are interpreted. This is quite different from the 
		<a href="../../articles/glossary.htm#Syntax">syntax</a> of a programming language which refers to how
        different symbols and reserved words are arranged.<p>For instance, in both Visual Basic
        and C++, the following is a valid expression:</p>
          <table border="0" class="ssCodeTable" cellspacing="0" cellpadding="0">
            <tr>
              <td width="100%" class="ssCodeTableBody">a &amp; b</td>
            </tr>
          </table>
        <p>Even though the syntax is the same between the two languages, the semantics are quite
        different. In C++, this expression is interpreted as a binary-and of &quot;a&quot; and
        &quot;b&quot;. In Visual Basic, however, this expression returns the concatenation of two
        strings.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Syntax"></a><span class="ssListHeaderText">Symbol</span></td>
        <td class="ssListItemCell">In parsing terms, a symbol is the building block of a grammar
        and can be either a <a href="#Terminal">terminal</a> or 
		<a href="Nonterminal">nonterminal</a>. Essentially, the term &quot;symbol&quot;
        is used to refer to either of its two forms.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Syntax"></a><span class="ssListHeaderText">Syntax</span></td>
        <td class="ssListItemCell">The term &quot;syntax&quot; refers to the structure of a
        programming language, in particular, the different series of symbols and words that make
        up the basic parts of the language. This is quite different from the programming
        language's<a href="#Semantics"> semantics</a> - the actual meaning of those
        different parts.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Shift"></a><span class="ssListHeaderText">Shift</span></td>
        <td class="ssListItemCell">A &quot;shift&quot; is an action performed by a parsing 
		engine when it reads a token that is valid in the current state.
		<a href="#Lookahead">Lookahead</a> parsers maintain a list of<a href="#Terminal"> terminals</a> which are expected to be read from each state,
        given that the syntax of the program is correct. If the token is not the expected, a
        syntax error occurs.<p>In the bottom-up parser engines, such as GOLD and YACC, a shift
        pushes the token onto an internal stack that is used to hold tokens that are being used to
        construct <a href="../../articles/glossary.htm#CompletedRule">completed 
		productions</a>.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="ShiftReduceConflict"></a><span class="ssListHeaderText">Shift-Reduce<br>
        Conflict</span></td>
        <td class="ssListItemCell">The Shift-Reduce Conflict is the most common type of conflict
        found in grammars. It is caused when the grammar allows a 
		<a href="#Production">production</a>
        to be <a href="#Reduce">reduced</a>&nbsp; for particular token, but, at the
        same time, allowing another rule to be 
		<a href="Shift">shifted</a> for that
        same token.<p>As a result, the grammar is ambiguous since a program can be interpreted
        more than one way.</p>
        <p>This error is often caused by recursive grammar definitions where the system cannot
        determine when one rule is complete and another is just started. The Builder documentation
        contains an 
		<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="example-if-then-else.htm">example</a> of
        the common if-then-else grammar problem and how to fit it.</td>
      </tr>
      <tr>
        <td class="ssListItemCell" nowrap><a name="Terminal"></a><span class="ssListHeaderText">Terminal</span></td>
        <td class="ssListItemCell">In Backus-Naur Form, a terminal is used to denote a programming
        language's reserved words and symbols. Please see thePlease see the<img src="../../images/inline-link.gif" alt="inline-arrow-r.gif (99 bytes)" hspace="3" WIDTH="5" HEIGHT="9"><a href="define-rules.htm">Define 
		Rules</a> page.</td>
      </tr>
      </table>
    </body>
</html>
